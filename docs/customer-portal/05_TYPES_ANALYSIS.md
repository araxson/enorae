# Customer Portal - Types Analysis

**Date**: 2025-10-25
**Portal**: Customer
**Layer**: Type Safety
**Files Analyzed**: 42
**Issues Found**: 3 (Critical: 0, High: 2, Medium: 1, Low: 0)

---

## Summary

- Verified feature modules rely on the generated Supabase types in `lib/types/database.types.ts`; no `any`/`@ts-ignore` usage found in customer code.
- However, several query files index into `Database['public']['Views']` entries that do not exist (`salons`, `appointment_services`, `sessions`, `user_roles`), which will fail under strict mode once type checking runs.
- Customer dashboard components re-use scheduling table types from the business portal. Those types represent raw schema tables and conflict with the public views customer queries are expected to consume.
- Some APIs side-step the type system with `as unknown as` casts, signalling missing DTO definitions and risking runtime drift.

---

## Issues

### High Priority

#### Issue #1: Invalid Database view references in query typings
**Severity**: High  
**File**: `features/customer/chains/api/queries.ts:8`, `features/customer/appointments/api/queries.ts:6-7`, `features/customer/sessions/api/queries.ts:6-7`, `features/customer/dashboard/api/queries/vip.ts:7`  
**Rule Violation**: TypeScript strict mode; Phase 1.5 schema alignment.

**Current Code**:
```ts
type Salon = Database['public']['Views']['salons']['Row']
type AppointmentService = Database['public']['Views']['appointment_services']['Row']
type Session = Database['public']['Views']['sessions']['Row']
type UserRole = Database['public']['Views']['user_roles']['Row']
```

**Problem**:
- The generated Supabase types expose `salons_view`, `appointment_services_view`, `sessions_view`, and `user_roles_view`. The identifiers without `_view` do not exist, so these type aliases become `never`/`any` depending on compiler flags.
- Downstream functions currently compile only because TypeScript treats the invalid index signature leniently; strict builds or IDE tooling surface errors.

**Required Fix**:
```ts
type Salon = Database['public']['Views']['salons_view']['Row']
type AppointmentService = Database['public']['Views']['appointment_services_view']['Row']
type Session = Database['public']['Views']['sessions_view']['Row']
type UserRole = Database['public']['Views']['user_roles_view']['Row']
```

**Steps to Fix**:
1. Update each alias to reference the actual `_view` export generated by Supabase.
2. Adjust query return handling (e.g., remove manual casts) to align with the corrected types.
3. Run `npm run typecheck` to confirm no residual index errors remain.

**Acceptance Criteria**:
- [ ] All `Database['public']['Views']` references map to existing entries.
- [ ] TypeScript compilation passes in strict mode.
- [ ] Kysely/Supabase helpers no longer infer `any` for these responses.

**Dependencies**: None.

---

#### Issue #2: Customer components rely on scheduling table rows (`AppointmentWithDetails`)
**Severity**: High  
**File**: `features/customer/dashboard/components/upcoming-bookings.tsx:8-17`, `features/customer/dashboard/components/appointment-history.tsx:8-20`, `features/customer/appointments/components/appointments-list.tsx:11-21`  
**Rule Violation**: TypeScript pattern rule – use `Database['public']['Views']` for customer-facing data.

**Current Code**:
```ts
import type { AppointmentWithDetails } from '@/features/business/appointments'
// features/business/appointments/types.ts:
export type AppointmentWithDetails = Database['scheduling']['Tables']['appointments']['Row']
```

**Problem**:
- The business portal’s `AppointmentWithDetails` type is the raw `scheduling.appointments` table row (includes internal columns like `created_by_id`, `updated_by_id`, etc.).
- Customer queries should consume `appointments_view` rows scoped by RLS. Once Layer 2 fixes swap the data source to the view, these components will mis-type the response and risk accidental property access (`salon_name`, `service_names`, etc.) that the table row does not expose.

**Required Fix**:
```ts
import type { Database } from '@/lib/types/database.types'

type CustomerAppointment = Database['public']['Views']['appointments_view']['Row']

interface UpcomingBookingsProps {
  appointments: CustomerAppointment[]
}
```
*(Create a portal-specific DTO if extra computed fields are needed.)*

**Steps to Fix**:
1. Replace cross-portal imports with a local `CustomerAppointment` type derived from `appointments_view`.
2. Audit property access in affected components; remove reliance on scheduling-only fields.
3. Regenerate Supabase types if needed and run `npm run typecheck`.

**Acceptance Criteria**:
- [ ] Dashboard/appointments components reference the public view type.
- [ ] No component imports table-row types from business features.
- [ ] TypeScript passes after query refactors (Layer 2).

**Dependencies**: Resolution of Layer 2 critical issues (switching queries to `appointments_view`).

---

### Medium Priority

#### Issue #3: Widespread `as unknown as` casts mask response typing gaps
**Severity**: Medium  
**File**: `features/customer/salon-detail/api/queries.ts:56-115`  
**Rule Violation**: Type Safety best practice – avoid double casts; prefer typed helpers.

**Current Code**:
```ts
const [
  { data: description },
  { data: contact },
  ...
] = await Promise.all([
  supabase
    .from('salon_descriptions_view')
    .select('short_description, full_description')
    .eq('salon_id', salon['id']!)
    .maybeSingle() as unknown as Promise<{ data: DescriptionRow | null; error: PostgrestError | null }>,
  supabase
    .from('salon_amenities')
    .select('amenities(id, name, icon)')
    .eq('salon_id', salon['id']!) as unknown as Promise<{ data: AmenityRow[] | null; error: PostgrestError | null }>,
```

**Problem**:
- The double cast bypasses Supabase’s typed response, making it easy to drift from the actual schema (e.g., if the view omits `amenities`, the cast will hide the error).
- The casts also conceal that `salon_amenities` is a schema table (see Layer 2/3 findings), compounding schema drift.

**Required Fix**:
```ts
const { data: description, error: descriptionError } = await supabase
  .from('salon_descriptions_view')
  .select('short_description, full_description')
  .eq('salon_id', salon.id)
  .maybeSingle<Pick<Database['public']['Views']['salon_descriptions_view']['Row'], 'short_description' | 'full_description'>>()

type AmenityView = Database['public']['Views']['salon_amenities_view']['Row']
const { data: amenitiesData, error: amenitiesError } = await supabase
  .from('salon_amenities_view')
  .select('*')
  .eq('salon_id', salon.id)
```

**Steps to Fix**:
1. Replace `as unknown as` with Supabase generics (e.g., `.maybeSingle<...>()`) or helper utilities that enforce the expected shape.
2. Swap table reads for public views (covered in earlier layers) so the types and schema align.
3. Bubble up any Supabase errors instead of discarding them in casts.
4. Run `npm run typecheck`.

**Acceptance Criteria**:
- [ ] No `as unknown as` casts remain in customer portal queries.
- [ ] Supabase generics or typed helpers model the response payload.
- [ ] TypeScript would surface schema drift instead of hiding it.

**Dependencies**: Execution of Layer 2/3 fixes to transition to the correct views.

---

## Statistics

- Total Issues: 3
- Files Affected: 6
- Estimated Fix Time: 1 day
- Breaking Changes: Medium (requires coordinated query refactors)

---

## Next Steps

1. Align all type aliases with the actual Supabase views before continuing with security/UX audits.
2. Introduce customer-specific DTOs (e.g., `CustomerAppointment`) instead of importing table-row types from other portals.
3. Replace double casts with typed Supabase helpers to ensure schema drift is caught at compile time.

---

## Related Files

This analysis should be done after:
- [x] docs/customer-portal/04_COMPONENTS_ANALYSIS.md

This analysis blocks:
- [ ] docs/customer-portal/07_SECURITY_ANALYSIS.md
