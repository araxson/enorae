#!/usr/bin/env python3
"""
Generate TypeScript types from Supabase database using MCP integration.

This script uses Claude's Supabase MCP to directly query the database schema
and generate accurate TypeScript type definitions.

Usage:
    python3 scripts/generate-types-mcp.py

Requirements:
    - Must be run through Claude Code with Supabase MCP configured
    - Project ID: nwmcpfioxerzodvbjigw
"""

import json
import sys
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List

PROJECT_ROOT = Path(__file__).parent.parent
OUTPUT_FILE = PROJECT_ROOT / "lib" / "types" / "database.types.ts"
PROJECT_ID = "nwmcpfioxerzodvbjigw"

# All schemas to introspect
SCHEMAS = [
    "public",
    "organization",
    "catalog",
    "scheduling",
    "identity",
    "communication",
    "analytics",
    "engagement",
    "audit",
    "security",
    "monitoring",
    "billing",
    "archive",
    "utility",
    "integration",
    "compliance",
    "patterns",
    "cache",
    "admin",
    "graphql_public",
]


def map_postgres_type_to_ts(
    data_type: str, udt_name: str, is_array: bool = False
) -> str:
    """Map PostgreSQL data types to TypeScript types."""

    # Handle arrays
    if is_array or data_type.startswith("ARRAY") or udt_name.startswith("_"):
        base_udt = udt_name.lstrip("_")
        base_type = map_postgres_type_to_ts(data_type.replace("ARRAY", ""), base_udt, False)
        return f"{base_type}[]"

    # Numeric types
    if udt_name in ["int2", "int4", "int8", "smallint", "integer", "bigint", "serial", "bigserial"]:
        return "number"
    if udt_name in ["float4", "float8", "numeric", "decimal", "real", "double precision"]:
        return "number"

    # String types
    if udt_name in ["varchar", "text", "char", "bpchar", "citext", "name"]:
        return "string"
    if udt_name in ["uuid"]:
        return "string"
    if udt_name in ["timestamp", "timestamptz", "date", "time", "timetz", "interval"]:
        return "string"

    # Boolean
    if udt_name in ["bool", "boolean"]:
        return "boolean"

    # JSON
    if udt_name in ["json", "jsonb"]:
        return "Json"

    # Binary and network types
    if udt_name in ["bytea", "inet", "cidr", "macaddr", "macaddr8"]:
        return "string"

    # Other types
    if udt_name in ["money"]:
        return "string"
    if udt_name == "void":
        return "void"

    # Fallback to unknown for custom types
    return "unknown"


def generate_typescript_interface(
    table_name: str,
    columns: List[Dict[str, Any]],
    is_view: bool = False
) -> Dict[str, Any]:
    """Generate TypeScript interface for a table or view."""

    row_type = {}
    insert_type = {}
    update_type = {}

    for col in columns:
        col_name = col["column_name"]
        data_type = col.get("data_type", "")
        udt_name = col.get("udt_name", "")
        is_nullable = col.get("is_nullable", "NO") == "YES"
        column_default = col.get("column_default")

        # Determine if column is an array
        is_array = data_type.startswith("ARRAY") or udt_name.startswith("_")

        # Map to TypeScript type
        ts_type = map_postgres_type_to_ts(data_type, udt_name, is_array)

        # Add null if nullable
        if is_nullable:
            ts_type = f"{ts_type} | null"

        # Row type - all columns
        row_type[col_name] = ts_type

        # Insert type - optional if has default or nullable
        has_default = column_default is not None
        is_generated = has_default and (
            "nextval" in str(column_default) or
            "gen_random_uuid" in str(column_default) or
            "now()" in str(column_default)
        )

        if is_view:
            insert_type[col_name] = "never"
            update_type[col_name] = "never"
        else:
            optional = is_nullable or has_default or is_generated
            insert_type[col_name] = {
                "type": ts_type,
                "optional": optional
            }
            update_type[col_name] = {
                "type": ts_type,
                "optional": True  # All fields optional in updates
            }

    return {
        "Row": row_type,
        "Insert": insert_type,
        "Update": update_type,
        "Relationships": []
    }


def format_typescript_output(database_schema: Dict[str, Any]) -> str:
    """Format the database schema as TypeScript code."""

    lines = []

    # Header
    lines.append("/**")
    lines.append(" * Supabase Database Types")
    lines.append(f" * Generated on {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')}")
    lines.append(" * DO NOT EDIT THIS FILE MANUALLY.")
    lines.append(" *")
    lines.append(f" * Project ID: {PROJECT_ID}")
    lines.append(" * Generated via: scripts/generate-types-mcp.py")
    lines.append(" */")
    lines.append("")

    # Json type
    lines.append("export type Json =")
    lines.append("  | string")
    lines.append("  | number")
    lines.append("  | boolean")
    lines.append("  | null")
    lines.append("  | { [key: string]: Json | undefined }")
    lines.append("  | Json[]")
    lines.append("")

    # Database interface
    lines.append("export interface Database {")

    for schema_name, schema_data in database_schema.items():
        lines.append(f"  {schema_name}: {{")

        # Tables
        lines.append("    Tables: {")
        if schema_data["Tables"]:
            for table_name, table_def in schema_data["Tables"].items():
                lines.append(f"      {table_name}: {{")

                # Row type
                lines.append("        Row: {")
                for col_name, col_type in table_def["Row"].items():
                    lines.append(f"          {col_name}: {col_type}")
                lines.append("        }")

                # Insert type
                lines.append("        Insert: {")
                for col_name, col_info in table_def["Insert"].items():
                    if col_info == "never":
                        lines.append(f"          {col_name}: never")
                    else:
                        optional_marker = "?" if col_info["optional"] else ""
                        lines.append(f"          {col_name}{optional_marker}: {col_info['type']}")
                lines.append("        }")

                # Update type
                lines.append("        Update: {")
                for col_name, col_info in table_def["Update"].items():
                    if col_info == "never":
                        lines.append(f"          {col_name}: never")
                    else:
                        lines.append(f"          {col_name}?: {col_info['type']}")
                lines.append("        }")

                lines.append("        Relationships: []")
                lines.append("      }")
        else:
            lines.append("      [_ in never]: never")
        lines.append("    }")

        # Views
        lines.append("    Views: {")
        if schema_data["Views"]:
            for view_name, view_def in schema_data["Views"].items():
                lines.append(f"      {view_name}: {{")

                # Row type
                lines.append("        Row: {")
                for col_name, col_type in view_def["Row"].items():
                    lines.append(f"          {col_name}: {col_type}")
                lines.append("        }")

                lines.append("        Insert: never")
                lines.append("        Update: never")
                lines.append("        Relationships: []")
                lines.append("      }")
        else:
            lines.append("      [_ in never]: never")
        lines.append("    }")

        # Functions (placeholder)
        lines.append("    Functions: {")
        lines.append("      [_ in never]: never")
        lines.append("    }")

        # Enums (placeholder)
        lines.append("    Enums: {")
        lines.append("      [_ in never]: never")
        lines.append("    }")

        # CompositeTypes (placeholder)
        lines.append("    CompositeTypes: {")
        lines.append("      [_ in never]: never")
        lines.append("    }")

        lines.append("  }")

    lines.append("}")
    lines.append("")

    # Helper types
    lines.append("// Helper types")
    lines.append("export type Tables<")
    lines.append("  PublicTableNameOrOptions extends")
    lines.append("    | keyof Database['public']['Tables']")
    lines.append("    | { schema: keyof Database },")
    lines.append("  TableName extends PublicTableNameOrOptions extends { schema: infer S extends keyof Database }")
    lines.append("    ? keyof Database[S]['Tables']")
    lines.append("    : never = never")
    lines.append("> = PublicTableNameOrOptions extends { schema: infer S extends keyof Database }")
    lines.append("  ? Database[S]['Tables'][TableName]['Row']")
    lines.append("  : PublicTableNameOrOptions extends keyof Database['public']['Tables']")
    lines.append("  ? Database['public']['Tables'][PublicTableNameOrOptions]['Row']")
    lines.append("  : never")
    lines.append("")
    lines.append("export type Views<T extends keyof Database['public']['Views']> = Database['public']['Views'][T]['Row']")
    lines.append("export type Enums<T extends keyof Database['public']['Enums']> = Database['public']['Enums'][T]")
    lines.append("")

    return "\n".join(lines)


def main():
    """Main entry point - prints SQL queries for Claude to execute via MCP."""

    print("=" * 80)
    print("DATABASE TYPE GENERATION USING SUPABASE MCP")
    print("=" * 80)
    print()
    print(f"Project ID: {PROJECT_ID}")
    print(f"Output: {OUTPUT_FILE}")
    print(f"Schemas: {len(SCHEMAS)}")
    print()

    # Print the SQL queries that Claude should execute
    print("=" * 80)
    print("EXECUTE THESE QUERIES VIA SUPABASE MCP:")
    print("=" * 80)
    print()

    for schema in SCHEMAS:
        print(f"-- Schema: {schema}")
        print(f"-- Get tables and views:")
        print(f"""
SELECT
    c.relname AS table_name,
    CASE c.relkind
        WHEN 'r' THEN 'table'
        WHEN 'v' THEN 'view'
        WHEN 'm' THEN 'view'
    END AS table_type
FROM pg_class c
JOIN pg_namespace n ON n.oid = c.relnamespace
WHERE n.nspname = '{schema}'
    AND c.relkind IN ('r', 'v', 'm')
ORDER BY c.relname;
""")

        print(f"-- Get columns for each table/view in {schema}:")
        print(f"""
SELECT
    c.relname AS table_name,
    a.attname AS column_name,
    t.typname AS udt_name,
    format_type(a.atttypid, a.atttypmod) AS data_type,
    NOT a.attnotnull AS is_nullable,
    pg_get_expr(ad.adbin, ad.adrelid) AS column_default
FROM pg_attribute a
JOIN pg_class c ON c.oid = a.attrelid
JOIN pg_namespace n ON n.oid = c.relnamespace
JOIN pg_type t ON t.oid = a.atttypid
LEFT JOIN pg_attrdef ad ON ad.adrelid = a.attrelid AND ad.adnum = a.attnum
WHERE n.nspname = '{schema}'
    AND c.relkind IN ('r', 'v', 'm')
    AND a.attnum > 0
    AND NOT a.attisdropped
ORDER BY c.relname, a.attnum;
""")
        print()

    print("=" * 80)
    print()
    print("NOTE: This script prints the SQL queries needed.")
    print("Claude will execute these via Supabase MCP and generate the types.")
    print()

    return 0


if __name__ == "__main__":
    sys.exit(main())
