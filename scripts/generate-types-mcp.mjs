#!/usr/bin/env node

/**
 * Generate TypeScript types using Supabase MCP list_tables
 * This works around CLI/psycopg authentication issues
 */

import { writeFileSync } from 'fs'
import { fileURLToPath } from 'url'
import { dirname, join } from 'path'
import { execSync } from 'child_process'

const __filename = fileURLToPath(import.meta.url)
const __dirname = dirname(__filename)
const PROJECT_ROOT = join(__dirname, '..')

const PROJECT_ID = 'nwmcpfioxerzodvbjigw'

const SCHEMAS = [
  'public',
  'organization',
  'catalog',
  'scheduling',
  'identity',
  'communication',
  'analytics',
  'engagement',
  'admin',
  'audit',
  'security',
  'monitoring',
  'billing',
  'archive',
  'utility',
  'integration',
  'compliance',
  'patterns',
  'cache'
]

console.log('üîÑ Generating Supabase TypeScript types using MCP...')
console.log(`üìä Schemas (${SCHEMAS.length}): ${SCHEMAS.join(', ')}`)

function listTables(schema) {
  try {
    const cmd = `claude-code mcp supabase list_tables --project_id="${PROJECT_ID}" --schemas='["${schema}"]' --format=json`
    const result = execSync(cmd, { cwd: PROJECT_ROOT }).toString()
    return JSON.parse(result)
  } catch (error) {
    console.error(`Failed to list tables for ${schema}:`, error.message)
    return []
  }
}

function mapDataType(dataType, format) {
  // Map PostgreSQL types to TypeScript
  const typeMap = {
    'uuid': 'string',
    'text': 'string',
    'varchar': 'string',
    'character varying': 'string',
    'character': 'string',
    'bigint': 'number',
    'integer': 'number',
    'smallint': 'number',
    'numeric': 'number',
    'real': 'number',
    'double precision': 'number',
    'boolean': 'boolean',
    'timestamptz': 'string',
    'timestamp with time zone': 'string',
    'timestamp without time zone': 'string',
    'timestamp': 'string',
    'date': 'string',
    'time': 'string',
    'interval': 'string',
    'jsonb': 'Json',
    'json': 'Json',
    'bytea': 'string',
    'inet': 'string',
    'cidr': 'string',
    'macaddr': 'string',
    'money': 'string'
  }

  // Check format first (more specific)
  if (typeMap[format]) return typeMap[format]

  // Then check data_type
  const lower = dataType.toLowerCase()
  if (typeMap[lower]) return typeMap[lower]

  // Handle arrays
  if (dataType.startsWith('ARRAY') || dataType.endsWith('[]')) {
    const baseType = dataType.replace('ARRAY', '').replace('[]', '').trim()
    const mapped = mapDataType(baseType, format)
    return `${mapped}[]`
  }

  return 'unknown'
}

function generateTS(database) {
  let ts = `/**
 * Supabase Database Types
 * Generated on ${new Date().toISOString()}
 * DO NOT EDIT THIS FILE MANUALLY.
 */

export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[]

export type Database = {
`

  for (const [schemaName, schemaData] of Object.entries(database)) {
    ts += `  ${schemaName}: {\n`

    // Tables
    ts += `    Tables: {\n`
    const tables = Object.entries(schemaData).filter(([_, t]) => !t.isView)
    if (tables.length === 0) {
      ts += `      [_ in never]: never\n`
    } else {
      for (const [tableName, table] of tables) {
        ts += `      ${tableName}: {\n`
        ts += `        Row: {\n`
        for (const col of table.columns) {
          const tsType = mapDataType(col.data_type, col.format)
          const nullable = col.options.includes('nullable') ? ' | null' : ''
          ts += `          ${col.name}: ${tsType}${nullable}\n`
        }
        ts += `        }\n`

        ts += `        Insert: {\n`
        for (const col of table.columns) {
          const tsType = mapDataType(col.data_type, col.format)
          const nullable = col.options.includes('nullable') ? ' | null' : ''
          const hasDefault = col.default_value !== undefined && col.default_value !== null
          const optional = col.options.includes('nullable') || hasDefault ? '?' : ''
          ts += `          ${col.name}${optional}: ${tsType}${nullable}\n`
        }
        ts += `        }\n`

        ts += `        Update: {\n`
        for (const col of table.columns) {
          const tsType = mapDataType(col.data_type, col.format)
          const nullable = col.options.includes('nullable') ? ' | null' : ''
          ts += `          ${col.name}?: ${tsType}${nullable}\n`
        }
        ts += `        }\n`

        ts += `        Relationships: []\n`
        ts += `      }\n`
      }
    }
    ts += `    }\n`

    // Views
    ts += `    Views: {\n`
    const views = Object.entries(schemaData).filter(([_, t]) => t.isView)
    if (views.length === 0) {
      ts += `      [_ in never]: never\n`
    } else {
      for (const [viewName, view] of views) {
        ts += `      ${viewName}: {\n`
        ts += `        Row: {\n`
        for (const col of view.columns) {
          const tsType = mapDataType(col.data_type, col.format)
          const nullable = col.options.includes('nullable') ? ' | null' : ''
          ts += `          ${col.name}: ${tsType}${nullable}\n`
        }
        ts += `        }\n`
        ts += `        Insert: never\n`
        ts += `        Update: never\n`
        ts += `        Relationships: []\n`
        ts += `      }\n`
      }
    }
    ts += `    }\n`

    ts += `    Functions: {\n      [_ in never]: never\n    }\n`
    ts += `    Enums: {\n      [_ in never]: never\n    }\n`
    ts += `    CompositeTypes: {\n      [_ in never]: never\n    }\n`
    ts += `  }\n`
  }

  ts += `}\n\n`

  // Helper types
  ts += `export type Tables<
  PublicTableNameOrOptions extends
    | keyof (Database["public"]["Tables"] & Database["public"]["Views"])
    | { schema: keyof Database },
  TableName extends PublicTableNameOrOptions extends { schema: keyof Database }
    ? keyof (Database[PublicTableNameOrOptions["schema"]]["Tables"] &
        Database[PublicTableNameOrOptions["schema"]]["Views"])
    : never = never,
> = PublicTableNameOrOptions extends { schema: keyof Database }
  ? (Database[PublicTableNameOrOptions["schema"]]["Tables"] &
      Database[PublicTableNameOrOptions["schema"]]["Views"])[TableName] extends {
      Row: infer R
    }
    ? R
    : never
  : PublicTableNameOrOptions extends keyof (Database["public"]["Tables"] &
        Database["public"]["Views"])
    ? (Database["public"]["Tables"] &
        Database["public"]["Views"])[PublicTableNameOrOptions] extends {
        Row: infer R
      }
      ? R
      : never
    : never

export type TablesInsert<
  PublicTableNameOrOptions extends
    | keyof Database["public"]["Tables"]
    | { schema: keyof Database },
  TableName extends PublicTableNameOrOptions extends { schema: keyof Database }
    ? keyof Database[PublicTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = PublicTableNameOrOptions extends { schema: keyof Database }
  ? Database[PublicTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Insert: infer I
    }
    ? I
    : never
  : PublicTableNameOrOptions extends keyof Database["public"]["Tables"]
    ? Database["public"]["Tables"][PublicTableNameOrOptions] extends {
        Insert: infer I
      }
      ? I
      : never
    : never

export type TablesUpdate<
  PublicTableNameOrOptions extends
    | keyof Database["public"]["Tables"]
    | { schema: keyof Database },
  TableName extends PublicTableNameOrOptions extends { schema: keyof Database }
    ? keyof Database[PublicTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = PublicTableNameOrOptions extends { schema: keyof Database }
  ? Database[PublicTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Update: infer U
    }
    ? U
    : never
  : PublicTableNameOrOptions extends keyof Database["public"]["Tables"]
    ? Database["public"]["Tables"][PublicTableNameOrOptions] extends {
        Update: infer U
      }
      ? U
      : never
    : never

export type Enums<
  PublicEnumNameOrOptions extends
    | keyof Database["public"]["Enums"]
    | { schema: keyof Database },
  EnumName extends PublicEnumNameOrOptions extends { schema: keyof Database }
    ? keyof Database[PublicEnumNameOrOptions["schema"]]["Enums"]
    : never = never,
> = PublicEnumNameOrOptions extends { schema: keyof Database }
  ? Database[PublicEnumNameOrOptions["schema"]]["Enums"][EnumName]
  : PublicEnumNameOrOptions extends keyof Database["public"]["Enums"]
    ? Database["public"]["Enums"][PublicEnumNameOrOptions]
    : never
`

  return ts
}

async function main() {
  const database = {}
  let totalTables = 0
  let totalViews = 0

  for (const schema of SCHEMAS) {
    process.stdout.write(`  Processing ${schema}... `)

    const tables = listTables(schema)

    if (!tables || tables.length === 0) {
      console.log('no tables')
      database[schema] = {}
      continue
    }

    database[schema] = {}

    for (const table of tables) {
      const isView = table.name.endsWith('_view') || table.name.endsWith('_mv')
      database[schema][table.name] = {
        columns: table.columns,
        isView
      }

      if (isView) {
        totalViews++
      } else {
        totalTables++
      }
    }

    console.log(`${tables.length} objects`)
  }

  const typescript = generateTS(database)
  const outputPath = join(PROJECT_ROOT, 'lib', 'types', 'database.types.ts')
  writeFileSync(outputPath, typescript, 'utf-8')

  console.log(`\n‚úÖ Successfully generated types!`)
  console.log(`üìÅ Output: lib/types/database.types.ts`)
  console.log(`üìä Schemas: ${SCHEMAS.length}`)
  console.log(`üìã Tables: ${totalTables}`)
  console.log(`üëÅÔ∏è  Views: ${totalViews}`)
  console.log(`üî¢ Total objects: ${totalTables + totalViews}`)
}

main().catch(error => {
  console.error('‚ùå Error:', error.message)
  process.exit(1)
})
